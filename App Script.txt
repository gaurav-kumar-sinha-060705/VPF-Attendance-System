// ===============================================================
// VPF ATTENDANCE TRACKER - GOOGLE APPS SCRIPT BACKEND (v7 - Type Safe & Unique Filenames)
// ===============================================================

// --- 1. CONFIGURATION ---
const SPREADSHEET_ID = "1-sgSeFZrNFGEZKKw8mth1XQ0n_2malSIxfWzPLBbt8g";
const IMAGE_FOLDER_ID = "1R19-DUPIV6EVC7G0hba3rKMgFB8Mataq";

const EMPLOYEES_SHEET_NAME = "Employees";
const ATTENDANCE_SHEET_NAME = "AttendanceLog";

const EMPLOYEE_HEADERS = ["ID", "Name", "ReferenceImageURL"];
const ATTENDANCE_HEADERS = ["LogID", "EmployeeID", "EmployeeName", "Date", "PunchInTime", "PunchInImageURL", "PunchOutTime", "PunchOutImageURL"];

// --- 2. GLOBAL VARIABLES ---
const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
const employeesSheet = ss.getSheetByName(EMPLOYEES_SHEET_NAME);
const attendanceSheet = ss.getSheetByName(ATTENDANCE_SHEET_NAME);
const imageFolder = DriveApp.getFolderById(IMAGE_FOLDER_ID);

// --- 3. MAIN ROUTERS ---
function doGet(e) {
  try {
    const action = e.parameter.action;
    switch (action) {
      case 'getEmployees':
        return createJsonResponse({ success: true, employees: getEmployees() });
      case 'getAttendance':
        return createJsonResponse({ success: true, records: getAttendanceRecords() });
      default:
        return createJsonResponse({ success: false, message: 'Invalid GET action.' });
    }
  } catch (error) {
    Logger.log(`doGet Error: ${error.stack}`);
    return createJsonResponse({ success: false, message: 'Server error: ' + error.message });
  }
}

function doPost(e) {
  try {
    const data = JSON.parse(e.postData.contents);
    switch (data.action) {
      case 'addEmployee':
        return createJsonResponse(addEmployee(data));
      case 'deleteEmployee':
        return createJsonResponse(deleteEmployee(data));
      case 'logAttendance':
        return createJsonResponse(logAttendance(data));
      case 'verifyAdminToken':
        return createJsonResponse(verifyAdminToken(data));
      default:
        return createJsonResponse({ success: false, message: 'Invalid POST action.' });
    }
  } catch (error) {
    Logger.log(`doPost Error: ${error.stack}`);
    return createJsonResponse({ success: false, message: 'Server error: ' + error.message });
  }
}

// --- 4. CORE LOGIC ---

function addEmployee(data) {
  const { id, name, imageBase64, mimeType } = data;
  if (!id || !name || !imageBase64 || !mimeType) throw new Error("Missing required data for adding an employee.");

  const lock = LockService.getScriptLock();
  lock.waitLock(15000);
  try {
    const existingIds = employeesSheet.getRange(2, 1, employeesSheet.getLastRow(), 1).getValues().flat().map(String);
    if (existingIds.includes(id.toString())) {
      return { success: false, message: `Employee ID "${id}" already exists.` };
    }

    const imageBlob = Utilities.newBlob(Utilities.base64Decode(imageBase64), mimeType, `${id}.jpg`);
    const file = imageFolder.createFile(imageBlob);
    const fileUrl = `https://lh3.googleusercontent.com/d/${file.getId()}`;
    
    employeesSheet.appendRow([id, name, fileUrl]);
    SpreadsheetApp.flush();
    return { success: true, message: "Employee added." };
  } finally {
    lock.releaseLock();
  }
}

function deleteEmployee(data) {
  const { id } = data;
  if (!id) throw new Error("Employee ID is required for deletion.");
  
  const lock = LockService.getScriptLock();
  lock.waitLock(15000);
  try {
    const dataRange = employeesSheet.getDataRange();
    const values = dataRange.getValues();
    const rowIndex = values.findIndex(row => row[0].toString() === id.toString());

    if (rowIndex > 0) {
      const imageUrl = values[rowIndex][2];
      try {
        const fileId = imageUrl.split('/d/')[1].split('/')[0];
        DriveApp.getFileById(fileId).setTrashed(true);
      } catch (e) {
        Logger.log(`Could not delete file for employee ${id}. URL: ${imageUrl}. Error: ${e.message}`);
      }
      employeesSheet.deleteRow(rowIndex + 1);
      SpreadsheetApp.flush();
      return { success: true, message: "Employee deleted." };
    }
    return { success: false, message: "Employee not found." };
  } finally {
    lock.releaseLock();
  }
}

function logAttendance(data) {
  const { employeeId, name, imageDataUrl, punchType } = data;
  if (!employeeId || !name || !imageDataUrl || !punchType) throw new Error("Missing data for attendance log (id, name, image, or type).");

  const lock = LockService.getScriptLock();
  lock.waitLock(20000);
  try {
    const now = new Date();
    const todayDateString = Utilities.formatDate(now, Session.getScriptTimeZone(), "yyyy-MM-dd");
    const nowIsoString = now.toISOString();

    const records = getAttendanceRecords();
    // CRITICAL FIX: Ensure IDs are compared as strings and compare only the date part for reliability.
    const todaysRecord = records.find(r => r.EmployeeID.toString() === employeeId.toString() && String(r.Date).split('T')[0] === todayDateString);
    const capturedImageBlob = Utilities.newBlob(Utilities.base64Decode(imageDataUrl.split(',')[1]), 'image/jpeg');

    // Face verification before recording attendance
    const employee = getEmployeeById(employeeId);
    if (!employee) {
      return { success: false, message: "Employee not found for face verification." };
    }
    const verification = verifyFace(employee.ReferenceImageURL, imageDataUrl);
    if (!verification.success) {
      return { success: false, message: verification.message || "Face verification failed." };
    }
    if (verification.isMatch === false || (typeof verification.confidence === 'number' && verification.confidence < 0.75)) {
      return { success: false, message: "Face does not match. Please try again or contact admin." };
    }

    let updatedLog;

    if (punchType === 'in') {
      if (todaysRecord && todaysRecord.PunchInTime) {
        return { success: false, message: "Your Punch In for today is already marked." };
      }
      // Use unique Employee ID in filename to prevent conflicts.
      const file = imageFolder.createFile(capturedImageBlob.setName(`${employeeId}-${todayDateString}-IN.jpg`));
      const imageUrl = `https://lh3.googleusercontent.com/d/${file.getId()}`;
      const logId = Utilities.getUuid();
      const newLogRow = [logId, employeeId, name, todayDateString, nowIsoString, imageUrl, "", ""];
      attendanceSheet.appendRow(newLogRow);
      updatedLog = arrayToLogObject(newLogRow);

    } else if (punchType === 'out') {
      if (!todaysRecord || !todaysRecord.PunchInTime) {
        return { success: false, message: "You must Punch In before you can Punch Out." };
      }
      if (todaysRecord.PunchOutTime) {
        return { success: false, message: "Your Punch Out for today is already marked." };
      }
      // Use unique Employee ID in filename to prevent conflicts.
      const file = imageFolder.createFile(capturedImageBlob.setName(`${employeeId}-${todayDateString}-OUT.jpg`));
      const imageUrl = `https://lh3.googleusercontent.com/d/${file.getId()}`;
      
      const rowIndex = findRowIndex(attendanceSheet, todaysRecord.LogID, 1);
      if (rowIndex > -1) {
        attendanceSheet.getRange(rowIndex, ATTENDANCE_HEADERS.indexOf("PunchOutTime") + 1).setValue(nowIsoString);
        attendanceSheet.getRange(rowIndex, ATTENDANCE_HEADERS.indexOf("PunchOutImageURL") + 1).setValue(imageUrl);
        const updatedRowValues = attendanceSheet.getRange(rowIndex, 1, 1, ATTENDANCE_HEADERS.length).getValues()[0];
        updatedLog = arrayToLogObject(updatedRowValues);
      } else {
        throw new Error("CRITICAL: Could not find original record to update for punch-out.");
      }
    } else {
      return { success: false, message: "Invalid punch type." };
    }

    SpreadsheetApp.flush();
    return { success: true, log: updatedLog };
  } finally {
    lock.releaseLock();
  }
}

// --- 5. HELPER & UTILITY FUNCTIONS ---

function getEmployees() {
  return sheetToObjects(employeesSheet, EMPLOYEE_HEADERS);
}

function getAttendanceRecords() {
  return sheetToObjects(attendanceSheet, ATTENDANCE_HEADERS);
}

// Lookup a single employee by ID
function getEmployeeById(id) {
  const data = sheetToObjects(employeesSheet, EMPLOYEE_HEADERS);
  return data.find(e => e.ID && e.ID.toString() === id.toString());
}

function sheetToObjects(sheet, headers) {
  if (!sheet) return [];
  const lastRow = sheet.getLastRow();
  if (lastRow < 2) return [];
  const data = sheet.getRange(2, 1, lastRow - 1, headers.length).getValues();
  return data.map(row => {
    let obj = {};
    headers.forEach((header, i) => {
        if ((header.includes('Date') || header.includes('Time')) && row[i] instanceof Date) {
            if (header.includes('Date')) {
                obj[header] = Utilities.formatDate(row[i], Session.getScriptTimeZone(), 'yyyy-MM-dd');
            } else {
                obj[header] = row[i].toISOString();
            }
        } else {
            obj[header] = row[i];
        }
    });
    return obj;
  });
}

function arrayToLogObject(rowArray) {
    let obj = {};
    ATTENDANCE_HEADERS.forEach((header, i) => {
        obj[header] = rowArray[i] === "" ? null : rowArray[i];
    });
    return obj;
}

function findRowIndex(sheet, valueToFind, column) {
    const data = sheet.getRange(1, column, sheet.getLastRow(), 1).getValues();
    for (var i = 0; i < data.length; i++) {
        if (data[i][0].toString() == valueToFind.toString()) { // Type-safe comparison
            return i + 1;
        }
    }
    return -1;
}

function createJsonResponse(obj) {
  return ContentService.createTextOutput(JSON.stringify(obj)).setMimeType(ContentService.MimeType.JSON);
}

// NOTE: Simple Google ID token verification for Admin login.
function verifyAdminToken(data) {
  const token = data && data.token;
  if (!token) {
    return { success: false, message: 'Missing token.' };
  }
  try {
    const url = 'https://oauth2.googleapis.com/tokeninfo?id_token=' + encodeURIComponent(token);
    const response = UrlFetchApp.fetch(url, { muteHttpExceptions: true });
    const text = response.getContentText();
    const info = JSON.parse(text);
    if (info.error_description || info.error) {
      return { success: false, message: info.error_description || info.error };
    }
    const user = {
      id: info.sub,
      name: info.name || info.email,
      email: info.email,
      picture: info.picture || ''
    };
    // Optionally validate audience against your OAuth client id if desired.
    // if (info.aud !== 'YOUR_GOOGLE_CLIENT_ID') return { success: false, message: 'Invalid audience.' };
    return { success: true, user: user };
  } catch (err) {
    return { success: false, message: 'Token verification failed: ' + err.message };
  }
}

// NOTE: Face verification using AI service for security.
function verifyFace(referenceImageUrl, capturedImageDataUrl) {
  try {
    const apiKey = PropertiesService.getScriptProperties().getProperty('API_KEY');
    if (!apiKey) {
      return { success: false, message: 'Missing API_KEY in Script Properties.' };
    }

    // Get reference image as base64 using Drive file id from URL
    let refBase64 = '';
    try {
      const fileId = referenceImageUrl.split('/d/')[1].split('/')[0];
      const blob = DriveApp.getFileById(fileId).getBlob();
      refBase64 = Utilities.base64Encode(blob.getBytes());
    } catch (e) {
      return { success: false, message: 'Unable to load reference image from Drive.' };
    }

    // Captured image base64 (strip data URL prefix)
    const capBase64 = capturedImageDataUrl.split(',')[1];

    const url = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=' + encodeURIComponent(apiKey);
    const prompt = 'Compare the two faces and respond ONLY with compact JSON like {"isMatch": true|false, "confidence": number between 0 and 1}. If unclear, return false with low confidence.';
    const payload = {
      contents: [{
        role: 'user',
        parts: [
          { text: prompt },
          { inlineData: { mimeType: 'image/jpeg', data: refBase64 } },
          { inlineData: { mimeType: 'image/jpeg', data: capBase64 } }
        ]
      }]
    };
    const res = UrlFetchApp.fetch(url, {
      method: 'post',
      contentType: 'application/json',
      payload: JSON.stringify(payload),
      muteHttpExceptions: true
    });
    const body = JSON.parse(res.getContentText());
    const text = body && body.candidates && body.candidates[0] && body.candidates[0].content && body.candidates[0].content.parts && body.candidates[0].content.parts[0] && body.candidates[0].content.parts[0].text || '';
    const jsonText = (function(s){
      const start = s.indexOf('{');
      const end = s.lastIndexOf('}');
      if (start >= 0 && end > start) return s.substring(start, end+1);
      return '';
    })(text);
    if (!jsonText) {
      return { success: false, message: 'Invalid response from AI service.' };
    }
    const parsed = JSON.parse(jsonText);
    return { success: true, isMatch: !!parsed.isMatch, confidence: Number(parsed.confidence) };
  } catch (err) {
    return { success: false, message: 'Face verification failed: ' + err.message };
  }
}